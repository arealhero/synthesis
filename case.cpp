
/* Заметка:

    Конечный код должен быть написан, как если бы
    он писался для рабочего проекта.

    Код может включать пример/тест, демонстрирующий работоспособность.
    Будет пример/тест или нет -- не важно.

    Можно использовать сторонние библиотеки
    или написать необходимый вспомогательный функционал.
    Можно использовать любой стандарт С++.
*/


#include <string>
#include <map>

using std::string;
using std::map;
using std::vector;

struct Element
{
    string name;
    map<string,string> properties;
    Element(const char* n) : name(n) {}
};

/*
    `View` -- класс, который отвечает за отображение элементов определенного типа(в данном случае `Element`).

    Необходимо добавить операцию поиска по элементам.
    Поиск должен быть максимально эффективным.
    И работать так, чтобы можно было реализовать пример ниже.

-----------------
    Ниже -- имеющийся интерфейс(объявления методов).
    Надо его реализовать(написать определения),
    и добавить неоходимые методы для реализации
    вышеописанного функционала.
-----------------
*/
struct View
{
    // `Range` является контейнером или массивом,
    // у которого типом элемента является `Element*`
    // Вызов этого конструкора должен быть равен
    // вызову конструктора по умолчанию
    // и вызову `add` на каждый элемент из `elements`
    template<class Range>
    View(Range& elements);

    View();

    // `add` и `remove` вызываются чрезвычайно редко
    void add(Element*);
    void remove(Element*);

    //! Возвращает кол-во видимых элементов
    int count() const;
    //! Возвращает i-тый видимый элемент
    Element* get(int i) const;
};
/*
    В качестве примера применения этого интерфейса
    представь дерево, которое отображает папки и файлы;
    у каждой папки имеется поле поиска,
    который ищет по файлам в ней. Но при этом
    сама иерархия папок определяется извне.
.
└──  🔍
    ├── 📁 A 🔍
    │   ├── 12
    │   └── 13
    └── 📁 D 🔍
        ├── 📁 B 🔍
        │   ├── 12
        │   ├── 22
        │   ├── 13
        │   └── 23
        └── 📁 C 🔍
            ├── 12
            ├── 13
            └── 123
.
└── 🔍 3
    ├── 📁 A 🔍
    │   └── 13
    └── 📁 D 🔍
        ├── 📁 B 🔍
        │   ├── 13
        │   └── 23
        └── 📁 C 🔍
            ├── 13
            └── 123
.
└── 🔍 3
    ├── 📁 A 🔍
    │   └── 13
    └── 📁 D 🔍 1
        ├── 📁 B 🔍
        │   └── 13
        └── 📁 C 🔍
            ├── 13
            └── 123
.
└── 🔍 3
    ├── 📁 A 🔍
    │   └── 13
    └── 📁 D 🔍 2
        ├── 📁 B 🔍
        │   └── 23
        └── 📁 C 🔍
            └── 123

            
    Плюс, представь несколько таких деревьев, которые находятся в отдельно друг от друга.
    От каждого дерева можно получить список View, которые в нем находятся.
    И есть глобальный поиск по всем этим деревьям.
    (Под поиском подразумевается поиск по имени элемента)
*/


int main()
{

}
